<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StorageImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.device.storage</a> &gt; <span class="el_source">StorageImpl.java</span></div><h1>StorageImpl.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2016 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License
 * you may obtain at
 *
 * 		http://www.apache.org/licenses/LICENSE-2.0
 *
 * You can redistribute, modify or publish any part of the code written within this file but as it
 * is described in the License, the software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.device.storage;

import android.Manifest;
import android.annotation.SuppressLint;
import android.content.Context;
import android.content.pm.PackageManager;
import android.os.Environment;
import android.os.Process;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.text.TextUtils;
import android.util.Log;

import java.io.File;
import java.io.FileFilter;
import java.io.FilenameFilter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import universum.studios.android.device.DeviceConfig;

/**
 * A {@link Storage} implementation.
 *
 * @author Martin Albedinsky
 */
final class StorageImpl implements Storage {

	/**
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	private static final String TAG = &quot;StorageImpl&quot;;

	/**
	 * Relative path to the directory on the external storage where a directory named by the package
	 * name of the current application should be created, so this application can store there its
	 * own persistent data which will be deleted as soon as the application will be uninstalled.
	 * &lt;p&gt;
	 * Constant value: &lt;b&gt;Android/data&lt;/b&gt;
	 */
<span class="nc" id="L65">	private static final String EXTERNAL_PACKAGE_STORAGE_PARENTS_PATH = &quot;Android&quot; + File.separator + &quot;data&quot;;</span>

	/**
	 * Interface ===================================================================================
	 */

	/**
	 * Static members ==============================================================================
	 */

	/**
	 * Lock used for synchronized operations.
	 */
<span class="nc" id="L78">	private static final Object LOCK = new Object();</span>

	/**
	 * StorageImpl singleton instance.
	 */
	@SuppressLint(&quot;StaticFieldLeak&quot;)
	private static StorageImpl sInstance;

	/**
	 * Members =====================================================================================
	 */

	/**
	 * Helper for create operations on files system.
	 */
<span class="nc" id="L93">	private final StorageAction SA_CREATE = new StorageAction.Create(this);</span>

	/**
	 * Helper for delete operations on file system.
	 */
<span class="nc" id="L98">	private final StorageAction SA_DELETE = new StorageAction.Delete(this);</span>

	/**
	 * Helper for copy operations on file system.
	 */
<span class="nc" id="L103">	private final StorageAction SA_COPY = new StorageAction.Copy(this);</span>

	/**
	 * Helper for move operations on file system.
	 */
<span class="nc" id="L108">	private final StorageAction SA_MOVE = new StorageAction.Move(this);</span>

	/**
	 * Application context obtained from the context passed during initialization of this wrapper.
	 */
	private final Context mContext;

	/**
	 * An application package name to create specific sub-directory in the external storage if it is
	 * available.
	 */
	private final String mPackageName;

	/**
	 * File representing the root directory of the external file system.
	 */
	private File mExternal;

	/**
	 * File representing the directory for the current application to store its data there. This
	 * directory will be created only if {@link #getStorage(int)} is called with {@link #EXTERNAL_PACKAGE}
	 * identifier and the external storage is at that particular time available.
	 */
	private File mExternalPackage;

	/**
	 * Constructors ================================================================================
	 */

	/**
	 * Creates a new instance of StorageImpl.
	 *
	 * @param applicationContext Application context used to access system services.
	 */
<span class="nc" id="L142">	private StorageImpl(Context applicationContext) {</span>
<span class="nc" id="L143">		this.mContext = applicationContext;</span>
<span class="nc" id="L144">		this.mPackageName = applicationContext.getPackageName();</span>
<span class="nc" id="L145">		this.checkExternalAvailability();</span>
<span class="nc" id="L146">	}</span>

	/**
	 * Methods =====================================================================================
	 */

	/**
	 * Returns or creates a new singleton instance of StorageImpl.
	 *
	 * @param context Context used by the storage implementation to access system services.
	 * @return Storage implementation with actual storage data available.
	 */
	@NonNull
	static StorageImpl getInstance(@NonNull Context context) {
<span class="nc" id="L160">		synchronized (LOCK) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">			if (sInstance == null) sInstance = new StorageImpl(context.getApplicationContext());</span>
<span class="nc" id="L162">		}</span>
<span class="nc" id="L163">		return sInstance;</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result createFile(@NonNull String path) {
<span class="nc" id="L171">		return createFile(BASE, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result createFile(@StorageDir int storage, @NonNull String path) {
<span class="nc bnc" id="L179" title="All 2 branches missed.">		if (StorageUtils.directoryExists(appendBasePath(storage, path))) {</span>
<span class="nc" id="L180">			return StorageAction.createResult(</span>
					ACTION_CREATE,
					&quot;Failed to create file. Directory with this name already exists.&quot;,
					path,
					NO_FLAGS,
					ERROR_FILE_SAME_AS_DIRECTORY
			);
		}
<span class="nc" id="L188">		return SA_CREATE.performFileAction(storage, NO_FLAGS, &quot;&quot;, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results createFiles(@NonNull String... paths) {
<span class="nc" id="L196">		return createFiles(BASE, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results createFiles(@StorageDir int storage, @NonNull String... paths) {
<span class="nc" id="L204">		return SA_CREATE.performFilesAction(storage, NO_FLAGS, &quot;&quot;, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result createDirectory(@NonNull String path) {
<span class="nc" id="L212">		return createDirectory(BASE, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result createDirectory(@StorageDir int storage, @NonNull String path) {
<span class="nc bnc" id="L220" title="All 2 branches missed.">		if (StorageUtils.directoryExists(appendBasePath(storage, path))) {</span>
<span class="nc" id="L221">			return StorageAction.createResult(</span>
					ACTION_CREATE,
					&quot;Failed to create file. Directory with this name already exists.&quot;,
					path,
					NO_FLAGS,
					ERROR_DIRECTORY_SAME_AS_FILE
			);
		}
<span class="nc" id="L229">		return SA_CREATE.performDirectoryAction(storage, NO_FLAGS, null, null, &quot;&quot;, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results createDirectories(@NonNull String... paths) {
<span class="nc" id="L237">		return createDirectories(BASE, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results createDirectories(@StorageDir int storage, @NonNull String... paths) {
<span class="nc" id="L245">		return SA_CREATE.performDirectoriesAction(storage, NO_FLAGS, null, null, &quot;&quot;, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result deleteFile(@NonNull String path) {
<span class="nc" id="L253">		return deleteFile(BASE, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result deleteFile(@StorageDir int storage, @NonNull String path) {
<span class="nc" id="L261">		return SA_DELETE.performFileAction(storage, NO_FLAGS, &quot;&quot;, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results deleteFiles(@NonNull String... paths) {
<span class="nc" id="L269">		return deleteFiles(BASE, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results deleteFiles(@StorageDir int storage, @NonNull String... paths) {
<span class="nc" id="L277">		return SA_DELETE.performFilesAction(storage, NO_FLAGS, &quot;&quot;, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result deleteDirectory(@NonNull String path) {
<span class="nc" id="L285">		return deleteDirectory(BASE, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result deleteDirectory(@StorageDir int storage, @NonNull String path) {
<span class="nc" id="L293">		return deleteDirectory(storage, null, null, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result deleteDirectory(@StorageDir int storage, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @NonNull String path) {
<span class="nc" id="L301">		return SA_DELETE.performDirectoryAction(storage, NO_FLAGS, filter, nameFilter, &quot;&quot;, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results deleteDirectories(@NonNull String... paths) {
<span class="nc" id="L309">		return deleteDirectories(BASE, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results deleteDirectories(@StorageDir int storage, @NonNull String... paths) {
<span class="nc" id="L317">		return deleteDirectories(storage, null, null, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results deleteDirectories(@StorageDir int storage, FileFilter filter, @Nullable FilenameFilter nameFilter, @NonNull String... paths) {
<span class="nc" id="L325">		return SA_DELETE.performDirectoriesAction(storage, NO_FLAGS, filter, nameFilter, &quot;&quot;, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result deleteFileOrDirectory(@NonNull String path) {
<span class="nc" id="L333">		return deleteFileOrDirectory(BASE, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result deleteFileOrDirectory(@StorageDir int storage, @NonNull String path) {
<span class="nc" id="L341">		return deleteFileOrDirectory(storage, null, null, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result deleteFileOrDirectory(@StorageDir int storage, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @NonNull String path) {
<span class="nc" id="L349">		return SA_DELETE.performFileOrDirectoryAction(storage, NO_FLAGS, filter, nameFilter, &quot;&quot;, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results deleteFilesOrDirectories(@NonNull String... paths) {
<span class="nc" id="L357">		return deleteFilesOrDirectories(BASE, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results deleteFilesOrDirectories(@StorageDir int storage, @NonNull String... paths) {
<span class="nc" id="L365">		return deleteFilesOrDirectories(storage, null, null, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results deleteFilesOrDirectories(@StorageDir int storage, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @NonNull String... paths) {
<span class="nc" id="L373">		return SA_DELETE.performFilesOrDirectoriesAction(storage, NO_FLAGS, filter, nameFilter, &quot;&quot;, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result copyFile(int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L381">		return copyFile(BASE, flags, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result copyFile(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L389">		return SA_COPY.performFileAction(storage, flags, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results copyFiles(@Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L397">		return copyFiles(BASE, flags, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results copyFiles(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L405">		return SA_DELETE.performFilesAction(storage, flags, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result copyDirectory(@Flags int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L413">		return copyDirectory(BASE, flags, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result copyDirectory(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L421">		return copyDirectory(storage, flags, null, null, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result copyDirectory(@StorageDir int storage, @Flags int flags, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L429">		return SA_DELETE.performDirectoryAction(storage, flags, filter, nameFilter, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results copyDirectories(@Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L437">		return copyDirectories(BASE, flags, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results copyDirectories(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L445">		return copyDirectories(storage, flags, null, null, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results copyDirectories(@StorageDir int storage, @Flags int flags, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L453">		return SA_DELETE.performDirectoriesAction(storage, flags, filter, nameFilter, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result copyFileOrDirectory(@Flags int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L461">		return copyFileOrDirectory(BASE, flags, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result copyFileOrDirectory(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L469">		return copyFileOrDirectory(storage, flags, null, null, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result copyFileOrDirectory(@StorageDir int storage, @Flags int flags, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L477">		return SA_COPY.performFileOrDirectoryAction(storage, flags, filter, nameFilter, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results copyFilesOrDirectories(@Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L485">		return copyFilesOrDirectories(BASE, flags, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results copyFilesOrDirectories(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L493">		return copyFilesOrDirectories(storage, flags, null, null, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results copyFilesOrDirectories(@StorageDir int storage, @Flags int flags, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L501">		return SA_COPY.performFilesOrDirectoriesAction(storage, flags, filter, nameFilter, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result moveFile(@Flags int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L509">		return moveFile(BASE, flags, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result moveFile(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L517">		return SA_MOVE.performFileAction(storage, flags, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results moveFiles(@Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L525">		return moveFiles(BASE, flags, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results moveFiles(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L533">		return SA_MOVE.performFilesAction(storage, flags, toPath, fromPaths);</span>
	}

	@NonNull
	@Override
	public Result moveDirectory(@Flags int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L539">		return moveDirectory(BASE, flags, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result moveDirectory(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L547">		return moveDirectory(storage, flags, null, null, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result moveDirectory(@StorageDir int storage, @Flags int flags, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L555">		return SA_MOVE.performDirectoryAction(storage, flags, filter, nameFilter, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results moveDirectories(@Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L563">		return moveDirectories(BASE, flags, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results moveDirectories(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L571">		return moveDirectories(storage, flags, null, null, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results moveDirectories(@StorageDir int storage, @Flags int flags, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L579">		return SA_MOVE.performDirectoriesAction(storage, flags, filter, nameFilter, toPath, fromPaths);</span>
	}

	@NonNull
	@Override
	public Result moveFileOrDirectory(@Flags int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L585">		return moveFileOrDirectory(BASE, flags, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result moveFileOrDirectory(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L593">		return moveFileOrDirectory(storage, flags, null, null, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Result moveFileOrDirectory(@StorageDir int storage, @Flags int flags, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @Nullable String toPath, @NonNull String fromPath) {
<span class="nc" id="L601">		return SA_MOVE.performFileOrDirectoryAction(storage, flags, filter, nameFilter, toPath, fromPath);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results moveFilesOrDirectories(@Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L609">		return moveFilesOrDirectories(BASE, flags, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results moveFilesOrDirectories(@StorageDir int storage, @Flags int flags, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L617">		return moveFilesOrDirectories(storage, flags, null, null, toPath, fromPaths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public Results moveFilesOrDirectories(@StorageDir int storage, @Flags int flags, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @Nullable String toPath, @NonNull String... fromPaths) {
<span class="nc" id="L625">		return SA_MOVE.performFilesOrDirectoriesAction(storage, flags, filter, nameFilter, toPath, fromPaths);</span>
	}

	/**
	 */
	@Override
	public boolean changeFilePermissions(@NonNull String path, @FilePermissions int permissions, boolean ownerOnly) {
<span class="nc" id="L632">		return changeFilePermissions(BASE, path, permissions, ownerOnly);</span>
	}

	/**
	 */
	@Override
	public boolean changeFilePermissions(@StorageDir int storage, @NonNull String path, @FilePermissions int permissions, boolean ownerOnly) {
<span class="nc" id="L639">		final File file = this.newFile(storage, path);</span>
<span class="nc bnc" id="L640" title="All 4 branches missed.">		if (file.isFile() &amp;&amp; permissions &gt; 0) {</span>
<span class="nc bnc" id="L641" title="All 6 branches missed.">			if (file.setExecutable((permissions &amp; PERMISSION_EXECUTE) != 0, ownerOnly) &amp;&amp;</span>
<span class="nc bnc" id="L642" title="All 4 branches missed.">					file.setWritable((permissions &amp; PERMISSION_WRITE) != 0, ownerOnly) &amp;&amp;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">					file.setReadable((permissions &amp; PERMISSION_READ) != 0, ownerOnly)) {</span>
<span class="nc" id="L644">				return true;</span>
			}
<span class="nc" id="L646">			Log.e(TAG, &quot;Failed to change read/write/execute permissions(&quot; + permissions + &quot;) of file('&quot; + file.getPath() + &quot;').&quot;);</span>
		}
<span class="nc" id="L648">		return false;</span>
	}

	/**
	 */
	@Override
	public boolean hasFreeSpace(@StorageDir int storage, long bytes) {
<span class="nc" id="L655">		final File storageFile = getStorage(storage);</span>
<span class="nc bnc" id="L656" title="All 4 branches missed.">		return storageFile != null &amp;&amp; storageFile.getFreeSpace() &gt;= bytes;</span>
	}

	/**
	 */
	@Override
	public long getFreeSpace(@StorageDir int storage) {
<span class="nc" id="L663">		final File storageFile = getStorage(storage);</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">		return storageFile == null ? 0 : storageFile.getFreeSpace();</span>
	}

	/**
	 */
	@Override
	public boolean isExternalReadOnly() {
<span class="nc" id="L671">		return Environment.MEDIA_MOUNTED_READ_ONLY.equals(Environment.getExternalStorageState());</span>
	}

	/**
	 */
	@Override
	public boolean isExternalMounted() {
<span class="nc" id="L678">		return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());</span>
	}

	/**
	 */
	@Override
	public boolean isExternalAvailable() {
<span class="nc" id="L685">		return checkExternalAvailability();</span>
	}

	/**
	 * Checks whether the external storage is available or not. See {@link Environment#getExternalStorageState()}
	 * for more info.
	 * &lt;p&gt;
	 * &lt;b&gt;Note&lt;/b&gt;, that in case that the external storage is available, this will also initialize file
	 * for external dir and also, create sub-directory in the Android/data/ directory for the
	 * current application package name.
	 *
	 * @return {@code True} if external storage is &lt;b&gt;MOUNTED&lt;/b&gt; or &lt;b&gt;MOUNTED_READ_ONLY&lt;/b&gt;.
	 */
	private boolean checkExternalAvailability() {
		String status;
		boolean available;
<span class="nc" id="L701">		final String state = Environment.getExternalStorageState();</span>
<span class="nc bnc" id="L702" title="All 4 branches missed.">		if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">			if (mExternal == null) {</span>
<span class="nc" id="L704">				this.mExternal = Environment.getExternalStorageDirectory();</span>
			}
<span class="nc" id="L706">			status = &quot;available&quot;;</span>
<span class="nc" id="L707">			available = true;</span>
		} else {
<span class="nc" id="L709">			this.mExternal = null;</span>
<span class="nc" id="L710">			this.mExternalPackage = null;</span>
<span class="nc" id="L711">			status = &quot;not available&quot;;</span>
<span class="nc" id="L712">			available = false;</span>
		}
<span class="nc" id="L714">		this.logMessage(&quot;External storage is &quot; + status + &quot;.&quot;, false);</span>
<span class="nc" id="L715">		return available;</span>
	}

	/**
	 */
	@NonNull
	@Override
	public String getStoragePath(@StorageDir int storage) {
<span class="nc bnc" id="L723" title="All 2 branches missed.">		if (storage == BASE) {</span>
<span class="nc" id="L724">			return &quot;&quot;;</span>
		}
<span class="nc" id="L726">		final File storageFile = getStorage(storage);</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">		return storageFile == null ? &quot;&quot; : storageFile.getPath();</span>
	}

	/**
	 */
	@Nullable
	@Override
	public File getStorage(@StorageDir int storage) {
<span class="nc bnc" id="L735" title="All 7 branches missed.">		switch (storage) {</span>
			case INTERNAL:
<span class="nc" id="L737">				return mContext.getFilesDir();</span>
			case EXTERNAL:
<span class="nc bnc" id="L739" title="All 2 branches missed.">				if (checkExternalAvailability()) return mExternal;</span>
<span class="nc" id="L740">				else return null;</span>
			case EXTERNAL_PACKAGE:
<span class="nc bnc" id="L742" title="All 2 branches missed.">				if (checkExternalAvailability()) {</span>
<span class="nc" id="L743">					this.ensureExternalPackageDir();</span>
<span class="nc" id="L744">					return mExternalPackage;</span>
				}
<span class="nc" id="L746">				return null;</span>
			case ROOT:
<span class="nc" id="L748">				return Environment.getRootDirectory();</span>
			case DATA:
<span class="nc" id="L750">				return Environment.getDataDirectory();</span>
			case CACHE:
<span class="nc" id="L752">				return mContext.getCacheDir();</span>
			case BASE:
			default:
<span class="nc" id="L755">				return null;</span>
		}
	}

	/**
	 * Ensures that a directory on the external storage for the current application &lt;var&gt;mPackageName&lt;/var&gt;
	 * is created if does not exist yet.
	 * &lt;p&gt;
	 * Directory will be created with the path: {@link #EXTERNAL_PACKAGE_STORAGE_PARENTS_PATH} + mPackageName,
	 * so for example for application with package name {@code com.google.docs}, this will create
	 * a directory with path {@code Android/data/com.google.docs/}.
	 *
	 * @return {@code True} if the directory has been successfully created or already exists,
	 * {@code false} if the external storage is not available at this time or permission to write
	 * external directory has not been granted yet.
	 */
	private boolean ensureExternalPackageDir() {
<span class="nc bnc" id="L772" title="All 2 branches missed.">		if (mExternal == null) return false;</span>
<span class="nc bnc" id="L773" title="All 4 branches missed.">		if (mExternalPackage != null &amp;&amp; mExternalPackage.isDirectory()) return true;</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">		if (mExternalPackage == null) {</span>
			// Build the path to the external storage directory specific for the package name of
			// this application.
<span class="nc" id="L777">			this.mExternalPackage = new File(mExternal.getPath() +</span>
					File.separator +
					EXTERNAL_PACKAGE_STORAGE_PARENTS_PATH +
					File.separator +
					mPackageName
			);
		}
		// Check whether we have permission to write on external storage.
<span class="nc bnc" id="L785" title="All 2 branches missed.">		if (mContext.checkPermission(</span>
				Manifest.permission.WRITE_EXTERNAL_STORAGE,
<span class="nc" id="L787">				Process.myPid(),</span>
<span class="nc" id="L788">				Process.myUid()</span>
		) != PackageManager.PERMISSION_GRANTED) {
<span class="nc" id="L790">			return false;</span>
		}
		// Create if not exists.
<span class="nc bnc" id="L793" title="All 4 branches missed.">		if (mExternalPackage.isDirectory() || mExternalPackage.mkdirs()) {</span>
<span class="nc" id="L794">			return true;</span>
		}
<span class="nc" id="L796">		this.logMessage(&quot;Failed to create external directory(&quot; + mExternalPackage.getPath() + &quot;) for package(&quot; + mPackageName + &quot;).&quot;, true);</span>
<span class="nc" id="L797">		return false;</span>
	}

	/**
	 */
	@NonNull
	@Override
	public File getFile(@StorageDir int storage, @NonNull String path) {
<span class="nc" id="L805">		return this.newFile(storage, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public List&lt;File&gt; getDirectoryContent(@NonNull String path) {
<span class="nc" id="L813">		return getDirectoryContent(BASE, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public List&lt;File&gt; getDirectoryContent(@StorageDir int storage, @NonNull String path) {
<span class="nc" id="L821">		return getDirectoryContent(storage, null, null, path);</span>
	}

	/**
	 */
	@NonNull
	@Override
	@SuppressWarnings(&quot;unchecked&quot;)
	public List&lt;File&gt; getDirectoryContent(@StorageDir int storage, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @NonNull String path) {
<span class="nc" id="L830">		final File dir = this.newFile(storage, path);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">		if (dir.isDirectory()) {</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">			if (filter == null) {</span>
<span class="nc" id="L833">				final File[] files = dir.listFiles(nameFilter);</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">				return isArrayEmpty(files) ? Collections.EMPTY_LIST : Arrays.asList(files);</span>
			} else {
				// First, filter by file.
<span class="nc" id="L837">				final File[] filteredFiles = dir.listFiles(filter);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">				if (isArrayEmpty(filteredFiles)) {</span>
<span class="nc" id="L839">					return Collections.EMPTY_LIST;</span>
				}
<span class="nc bnc" id="L841" title="All 2 branches missed.">				if (nameFilter != null) {</span>
<span class="nc" id="L842">					final List&lt;File&gt; files = new ArrayList&lt;&gt;();</span>
					// Now filter by name.
<span class="nc bnc" id="L844" title="All 2 branches missed.">					for (final File file : filteredFiles) {</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">						if (nameFilter.accept(file, file.getName())) {</span>
<span class="nc" id="L846">							files.add(file);</span>
						}
					}
<span class="nc" id="L849">					return files;</span>
				}
<span class="nc" id="L851">				return Arrays.asList(filteredFiles);</span>
			}
		} else {
<span class="nc" id="L854">			this.logMessage(&quot;Cannot obtain content of directory. Directory(&quot; + dir.getPath() + &quot;) does not exist or it is not a directory.&quot;, true);</span>
		}
<span class="nc" id="L856">		return Collections.EMPTY_LIST;</span>
	}

	/**
	 * Creates a new file with the path created from the given relative &lt;var&gt;path&lt;/var&gt; and path
	 * of the specified &lt;var&gt;storage&lt;/var&gt; as base path.
	 *
	 * @param storage Type of storage of which path should be used as base for the requested file's
	 *                path.
	 * @param path    Relative path to be appended to the path of resolved &lt;var&gt;storage&lt;/var&gt; type.
	 * @return An instance of file the the requested path.
	 */
	private File newFile(int storage, String path) {
<span class="nc" id="L869">		return new File(buildPath(storage, path));</span>
	}

	/**
	 * Builds the full path from the given path and the path of the given &lt;var&gt;storage&lt;/var&gt; type.
	 *
	 * @param storage Type of storage of which path should be used as base for the requested path.
	 * @param path    Relative path to be appended to the path of resolved &lt;var&gt;storage&lt;/var&gt; type.
	 * @return Full path.
	 */
	private String buildPath(int storage, String path) {
<span class="nc" id="L880">		return getStoragePath(storage) + File.separator + path;</span>
	}

	/**
	 * Checks whether the given array is empty or not.
	 *
	 * @param array Array to check.
	 * @return {@code True} if the given array is {@code null} or if it doesn't have any
	 * items within it, {@code false} otherwise.
	 */
	private boolean isArrayEmpty(Object[] array) {
<span class="nc bnc" id="L891" title="All 4 branches missed.">		return array == null || array.length == 0;</span>
	}

	/**
	 */
	@NonNull
	@Override
	public List&lt;File&gt; getDirectoriesContent(@NonNull String... paths) {
<span class="nc" id="L899">		return getDirectoriesContent(BASE, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public List&lt;File&gt; getDirectoriesContent(@StorageDir int storage, @NonNull String... paths) {
<span class="nc" id="L907">		return getDirectoriesContent(storage, null, null, paths);</span>
	}

	/**
	 */
	@NonNull
	@Override
	public List&lt;File&gt; getDirectoriesContent(@StorageDir int storage, @Nullable FileFilter filter, @Nullable FilenameFilter nameFilter, @NonNull String... paths) {
<span class="nc" id="L915">		final List&lt;File&gt; files = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">		if (paths.length &gt; 0) {</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">			for (final String path : paths) {</span>
<span class="nc" id="L918">				files.addAll(getDirectoryContent(storage, filter, nameFilter, path));</span>
			}
<span class="nc" id="L920">			return files;</span>
		}
<span class="nc" id="L922">		return files;</span>
	}

	/**
	 * Returns a name of storage type represented by the specified &lt;var&gt;storage&lt;/var&gt; identifier.
	 *
	 * @param storage An identifier of the desired storage of which name is requested.
	 * @return Storage name or {@code &quot;&quot;} if unknown type or {@link #BASE} was requested.
	 */
	static String getStorageName(int storage) {
<span class="nc bnc" id="L932" title="All 7 branches missed.">		switch (storage) {</span>
			case INTERNAL:
<span class="nc" id="L934">				return &quot;INTERNAL&quot;;</span>
			case EXTERNAL:
<span class="nc" id="L936">				return &quot;EXTERNAL&quot;;</span>
			case EXTERNAL_PACKAGE:
<span class="nc" id="L938">				return &quot;EXTERNAL_PACKAGE&quot;;</span>
			case ROOT:
<span class="nc" id="L940">				return &quot;ROOT&quot;;</span>
			case DATA:
<span class="nc" id="L942">				return &quot;DATA&quot;;</span>
			case CACHE:
<span class="nc" id="L944">				return &quot;CACHE&quot;;</span>
			default:
<span class="nc" id="L946">				return &quot;&quot;;</span>
		}
	}

	/**
	 * Appends the path obtained by {@link #getStoragePath(int)} by the given &lt;var&gt;path&lt;/var&gt;.
	 *
	 * @param storage An identifier of the desired storage of which path to use as base path.
	 * @param path    The desired path which should be appended to the base path.
	 * @return Appended base path of the specified storage with the given path or just the given
	 * &lt;var&gt;path&lt;/var&gt; if the path of the specified storage is empty.
	 */
	String appendBasePath(int storage, String path) {
<span class="nc" id="L959">		final String basePath = getStoragePath(storage);</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">		return TextUtils.isEmpty(basePath) ? path : basePath + File.separator + path;</span>
	}

	/**
	 * Logs the given message using {@link Log} util.
	 *
	 * @param message Message to log.
	 * @param error   {@code True} to log message as error, {@code false}otherwise.
	 */
	private void logMessage(String message, boolean error) {
<span class="nc bnc" id="L970" title="All 2 branches missed.">		if (error) Log.e(TAG, message);</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">		else if (DeviceConfig.DEBUG_LOG_ENABLED) Log.d(TAG, message);</span>
<span class="nc" id="L972">	}</span>

	/**
	 * Inner classes ===============================================================================
	 */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.0</div></body></html>